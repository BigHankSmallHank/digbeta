\documentclass{sig-alternate-05-2015}

\begin{document}

%\setcopyright{}
%\doi{}
%\isbn{}
%\conferenceinfo{}
%\acmPrice{\$15.00}
% Author Metadata

\title{Trajectory Recommendation}

%\numberofauthors{}
%\author{
%\alignauthor
%\alignauthor
%\alignauthor
%}

\maketitle

%\begin{abstract}
%\end{abstract}

% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 

%\printccsdesc
%\keywords{}

\section{Proposed Method}


\subsection{Definition}
Given a set of Point/Place of Interest (POI) $P$ and a set of users $U$,
\begin{itemize}
\item \textbf{Travel History} $H_u$\cite{ijcai15} is an ordered sequence
      \begin{displaymath}
      H_u = ((p_1, t_{p_1}^a, t_{p_1}^d), \dots, (p_i, t_{p_i}^a, t_{p_i}^d), \dots), p_i \in P, u \in U
      \end{displaymath}
      where $t_{p_i}^a$, $t_{p_i}^d$ is the arrival and departure time of user $u$ at POI $p_i$ respectively
\item \textbf{Trajectories} $S_u$ is a set of ordered sequences, split $H_u$ if
      $\lvert t_{p_i}^d - t_{p_{i+1}}^a \rvert > \tau$\cite{ijcai15}
      i.e.,
      \begin{displaymath}
      S_u = \{((p_{s_j}, t_{p_{s_j}}^a, t_{p_{s_j}}^d), \dots, (p_{e_j}, t_{p_{e_j}}^a, t_{p_{e_j}}^d))\}
      \end{displaymath}
      where $p_{s_j}$ and $p_{e_j}$ is the start and end POI of the $j$-th trajectory of user $u$ respectively
\item \textbf{POI Category}: the categories (e.g., structures, entertainment and shopping etc.) of POIs.
\end{itemize}


\subsection{Problem Formulation}
\label{sec:formulation}
Given a set of POIs $P$, a set of trajectories ${S_u}, u \in U$ with visited POIs in $P$, 
a start POI $p_s$ and destination $p_e$ and an integer $2 < L \le |P|$,
trajectory Recommendation is to recommend the \textit{most likely} trajectory $(p_s, \dots, p_e)$ to user $u$ such that
the number of visited POIs is $L$.


\subsection{Ranking of POIs}
% ranking of POIs focus on modeling the (personalised) preference of POIs
Produce a ranking of POIs specific to user $u$ and constraint $(p_s, p_e, L)$ 
using rankSVM with linear kernel and $L2$ loss)\cite{lranksvm}, 
i.e.,
\begin{displaymath}
\min_{\mathbf{w}} \frac{1}{2} \mathbf{w}^T \mathbf{w} +
                  C \sum_{(i, j) \in P} \max \left( 0, 1 - \mathbf{w}^T (\mathbf{x}_i - \mathbf{x}_j) \right)^2
\end{displaymath}

Features for ranking:
\begin{itemize}
\item POI popularity\cite{ijcai15}: 
      \begin{displaymath}
      Pop(p) = \sum_{u \in U} \sum_{p_i \in H_u} \delta(p_i = p)
      \end{displaymath}
\item POI average visit duration\cite{ijcai15} for user $u$:
      \begin{displaymath}
          \bar{V}(p) = \frac{1}{N} \sum_{u \in U} \sum_{p_i \in H_u} (t_{p_i}^d - t_{p_i}^a) \delta(p_i = p),
      \end{displaymath}
      where $N = \sum_{u \in U} \sum_{p_i \in H_u} \delta(p_i = p)$ is the number of visits at POI $p$ of all users.
\item whether the category is the same as that of $p_s$ (and $p_e$)
\item distance (haversine formula \cite{wiki_haversine}) from $p_s$ (and $p_e$), 
      \begin{displaymath}
      d = 2 R_1 \arcsin \sqrt{ \sin^2 \left( \frac{\Delta \phi}{2} \right) + 
           \cos \phi_p \cos \phi_{p_s} \sin^2 \left( \frac{\Delta \lambda}{2} \right) }
      \end{displaymath}
            where $R_1 = 6371.0088$ km is the mean earth radius \cite{wiki_earth_radius}, 
            $\phi$ and $\lambda$ are the latitude and longitude of the corresponding POI respectively
\item difference in popularity from $p_s$ (and $p_e$)
\item difference in average visit duration from that of $p_s$ (and $p_e$)
\item the number of POIs in trajectory, i.e. $L$
\end{itemize}

The ranking scores of POIs are transformed to probabilities using Platt scaling\cite{platt99} by
\begin{displaymath}
    %Pr(y=1 |p) = \frac{1}{1 + e^{A f(x) + B}, p \in P
    Pr(Rank_p) = \frac{1}{1 + e^{\alpha R(p) + \beta}}, p \in P
\end{displaymath}
where $R(p)$ is the ranking score of POI $p$, $\alpha$ and $\beta$ are parameters learned from training data\cite{plattnote07}.


\subsection{Factorise Transition Probabilities between POIs}
We factorise the transition probabilities between POIs using the following features:
\begin{itemize}
\item POI category $Cat(p), p \in P$
\item POI popularity, $Pop(p), p \in P$
\item POI average visit duration $\bar{V}(p), p \in P$
\item neighborhood relationship between POIs $Neighb(p), p \in P$
\end{itemize}
As the popularity and average visit duration of POIs are continous values, 
they are discritized with uniform log-scale bins,
in addition,
POIs are grouped into several clusters according to their geographical coordinates using K-means
to reflect their neighborhood relationships.

Thus, the transition probability between $p_i$ and $p_j$ can be factorised into the product of
transition probabilities of the above individual features between $p_i$ and $p_j$, 
assuming independence between these features,
i.e.,
\begin{align*}
    Pr(p_j | p_i) = & \frac{1}{Z_i} Pr(Cat(p_j) | Cat(p_i)) \times \\ 
                    & Pr(Pop(p_j) | Pop(p_i)) \times \\
                    & Pr(\bar{V}(p_j) | \bar{V}(p_i)) \times \\
                    & Pr(Neighb(p_j) | Neighb(p_i)) \\
                    & i \ne j, p_i, p_j \in P
\end{align*}
where $Z_i$ is a normalising constant.

\subsection{Recommend Trajectories}
% ranking of POIs focus on modeling the (population) preference of POIs
% MC focus on modeling the transition patterns between POIs
% we can capture both aspects by combining them
% TODO: explain no self-loop in graph G?
We create a weighted directed graph $G$ with vertices $V$ the set of POIs $P$ and 
edges $E$ the transitions between POIs,
the weight of vertex $v_{p}, p \in P$ is the negative logarithm of ranking probability of POI $p$, 
i.e.,
$w(v_{p}) = -\log(Pr(Rank_p)), p \in P$,
the weight of directed edge $(v_p, v_{p'})$ is the negative logarithm of transition probability between POI $p$ and $p'$,
i.e.,
$w(v_p, v_{p'}) = -\log(Pr(v_{p'} |v_p))$.

Compute the most likely trajectory given constraint $(p_s, p_e, L)$ is
equivalent to find a path (not necessarily a simple path) from vertex $v_{p_s}$ to
vertex $v_{p_e}$ which minimize the total path weights and with exactly $L$ vertices,
i.e.,
\begin{align*}
    \text{minimize~} & \sum_{i=1}^{L} w(v_i) + \sum_{i=1}^{L-1} w(v_i, v_{i+1}) \\
    \text{s.t.~~~~~} & v_1 = v_{p_s} \\
                     & v_L = v_{p_e} 
\end{align*}
    
The path can be found using dynamic programming, 
with array $A[l, v]$ stores the minimum total weights of path 
that starts at vertex $v_{p_s}$ and ends at vertex $v$ with 
exactly $l$ vertices in path and 
array $B[l, v]$ stores the predecessor of $v$ in that path,
to compute a path with $l+1$ vertices,
\begin{align*}
    A[l+1, v] &= \min_{v' \in Pa_v} \{ A[l, v'] + w(v', v) + w(v') + w(v) \} \\
    B[l+1, v] &= \text{argmin}_{v' \in Pa_v} \{ A[l, v'] + w(v', v) + w(v') + w(v) \} 
\end{align*}
where $Pa_v$ is the parent of vertex $v$, 
i.e., 
there is a directed edge from $v', v' \in Pa_v$ to $v$.

The minimum path weight is $A[L, v_{p_e}]$,
the actual path can be found by tracing back from $B[L, v_{p_e}]$,
the algorithm is shown in figure \ref{fig:path},
the sequence of POIs corresponding to vertices in that path is the 
trajectory we would like to recommend.

\begin{figure*}
\centering
\begin{tabular}{rl}
\hline
 1:&\textbf{procedure} FindPath$(V, E, p_s, p_e, L)$ \\
 2:&\hspace{10pt} \textbf{for} $v \in V$ \\
 3:&\hspace{20pt}     \textbf{if} $(v_{p_s}, v) \in E$ \\
 4:&\hspace{30pt}         $A[2, v] = w(v_{p_s}, v) + w(v_{p_s}) + w(v)$ \\
 5:&\hspace{30pt}         $B[2, v] = v_{p_s}$ \\
 6:&\hspace{20pt}     \textbf{else} \\
 7:&\hspace{30pt}         $A[2, v] = +\infty$ \\
 8:&\hspace{10pt} \textbf{end for} \\
 9:&\hspace{10pt} \textbf{for} $l=3$ \textbf{to} $L$ \\
10:&\hspace{20pt}     \textbf{for} $v \in V$ \\
11:&\hspace{30pt}         $A[l, v] = \min_{v' \in Pa_v} \{ A[l-1, v'] + w(v', v) + w(v') + w(v) \}$ \\
12:&\hspace{30pt}         $B[l, v] = \text{argmin}_{v' \in Pa_v} \{ A[l-1, v'] + w(v', v) + w(v') + w(v) \}$ \\
13:&\hspace{20pt}     \textbf{end for} \\
14:&\hspace{10pt} \textbf{end for} \\
% //trace back to find the actual path
15:&\hspace{10pt} $path = [v_{p_e}]$ \\
16:&\hspace{10pt} $v = path[0]$ \\
17:&\hspace{10pt} $l = L$ \\
18:&\hspace{10pt} \textbf{repeat} \\
19:&\hspace{20pt}     $path$.prepend$(B[l, v])$ \\
20:&\hspace{20pt}     $v = path[0]$ \\
21:&\hspace{20pt}     $l = l - 1$ \\
22:&\hspace{10pt} \textbf{util} $v == v_{p_s}$ \\
23:&\hspace{10pt} \textbf{return} $path$ \\
24:&\textbf{end procedure} \\
\hline
\end{tabular}
\caption{Path Finding}
\label{fig:path}
\end{figure*}


%\section{Acknowledgments}

\bibliographystyle{abbrv}
\bibliography{ref}

\end{document}
